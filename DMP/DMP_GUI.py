#Jon L. Battison
#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 4.22
#  in conjunction with Tcl version 8.6
#    Apr 02, 2019 10:24:38 AM EDT  platform: Windows NT

import pip
import os
import sys
import queue
import random
import threading
from time import sleep

import NetworkHandler as nh
try:
    import zlib
except ModuleNotFoundError:
    os.system('pip install zlib')
try:
    import pickle
except ModuleNotFoundError:
    os.system('pip install pickle')
try:
    import difflib
except ModuleNotFoundError:
    os.system('pip install difflib')
try:
    import fleep as fmt
except ModuleNotFoundError:
    os.system('pip install fleep')    
try:
    from mutagen.mp3 import MP3
except ModuleNotFoundError:
    os.system('pip install mutagen')
from mutagen.id3 import ID3, ID3NoHeaderError
try:
    from pygame import mixer
except ModuleNotFoundError:
    os.system('pip install pygame')
try:
    from pydub import AudioSegment
except ModuleNotFoundError:
    os.system('pip install pydub')
try:
    import tkinter as tk
except ModuleNotFoundError:
    os.system('pip install tkinter')   
from tkinter import filedialog
from tkinter import simpledialog
import tkinter.messagebox
    
try:
    import ttk
    py3 = False
except ImportError:
    import tkinter.ttk as ttk
    py3 = True

import DMP_GUI_support

def vp_start_gui():
    '''Starting point when module is the main routine.'''
    global val, w, root
    root = tk.Tk()
    top = DMP_GUI (root)
    DMP_GUI_support.init(root, top)
    root.mainloop()

w = None
def create_DMP_GUI(root, *args, **kwargs):
    '''Starting point when module is imported by another program.'''
    global w, w_win, rt
    rt = root
    w = tk.Toplevel (root)
    top = DMP_GUI (w)
    DMP_GUI_support.init(w, top, *args, **kwargs)
    return (w, top)

def destroy_DMP_GUI():
    global w
    if w == None:
        w = tk.Toplevel (root)
    w.destroy()
    w = None

class DMP_GUI:
    def __init__(self, top=None):
        #Globals
        self.shutdown = threading.Event() #event to signal to threads to close
        self.busy = threading.Event() #event to keep background tasks from occuring
        self.busy.set() #set allows functions to skip wait() 
        self.dir_path = os.path.dirname(os.path.realpath(__file__))
        self.playlist = {}
        self.devicelist = {}
        self.index = 0
        self.current_time = 0
        self.title = ''
        self.playlist_name = ''
        self.volume = 0.7
        self.volAtMute = 0
        self.net_rdy = False
        self.muted = False
        self.paused = False
        self.adj_bar = False
        self.req_remote = False
        
        self.port = 25011 #user can update, will pull from settings.dat
        
        #thread storage
        self.threads = []
        
        #add settings
        self.settings = {}
        self.settings['name'] = ''

        self.non_user_data_names = []
        
        self.dir_file_name = 'dir.dat'
        self.non_user_data_names.append(self.dir_file_name)#add to checklist
        self.lastList_file_name = 'last_list.dat'
        self.non_user_data_names.append(self.lastList_file_name)#add to checklist
        self.settings_file_name = 'settings.dat'
        self.non_user_data_names.append(self.settings_file_name)#add to checklist
        
        self.lastList_file_loc = os.path.join(self.dir_path,'data',self.lastList_file_name)
        self.dir_file_loc = os.path.join(self.dir_path,'data',self.dir_file_name)
        self.settings_file_loc = os.path.join(self.dir_path,'data',self.settings_file_name)
        self.pList_file_loc = os.path.join(self.dir_path,'data')
        
        self.pause_event = threading.Event()
        self.pause_event.set() #set allows playing
        self.remote_play_event = threading.Event()
        self.stream_next = False

        #for passiing information along server
        self.infoQ = queue.Queue(1)
        self.infoQ.put({'netList':[],'titleList':[],'deviceName':''})
        #for retrieving info from server
        self.serverQ = queue.Queue(1) 
        self.serverQ.put({'remove':[],'requests':[]})
        
        '''This class configures and populates the toplevel window.
           top is the toplevel containing window.'''
        _bgcolor = '#d9d9d9'  # X11 color: 'gray85'
        _fgcolor = '#000000'  # X11 color: 'black'
        _compcolor = '#d9d9d9' # X11 color: 'gray85'
        _ana1color = '#d9d9d9' # X11 color: 'gray85'
        _ana2color = '#ececec' # Closest X11 color: 'gray92'
        self.style = ttk.Style()
        if sys.platform == "win32":
            self.style.theme_use('winnative')
        #if sys.platform =='linux':
            #top.attributes('-fullscreen', True)
        self.style.configure('.',background=_bgcolor)
        self.style.configure('.',foreground=_fgcolor)
        self.style.configure('.',font="TkDefaultFont")
        self.style.map('.',background=
            [('selected', _compcolor), ('active',_ana2color)])
        
        top.geometry("782x483+757+324")
        top.title("Distributed Music Player")
        top.configure(background="#d9d9d9")
        top.configure(highlightbackground="#d9d9d9")
        top.configure(highlightcolor="black")
         
        ## initilizing the network manager
        self.update_titles()#updates titles available for remote clients
        self.network = nh.NetworkHandler(self.infoQ, self.serverQ, self.go_to_next, self.port, 
            self.busy, self.remote_play_event, self.pause_event) #25011 is the chosen port
        
        ## initializing the mixer
        mixer.init()
        
        # Create the menubar
        menubar = tk.Menu(top)
        top.config(menu=menubar)

        # Create the submenu
        subMenu = tk.Menu(menubar, tearoff=0)

        # Create the statusbar
        self.statusbar = ttk.Label(top, text="Distributed Music Player", relief=tk.SUNKEN, anchor=tk.W, font='Times 15 italic')
        self.statusbar.pack(side=tk.BOTTOM, fill=tk.X)


        menubar.add_cascade(label="File", menu=subMenu)
        subMenu.add_command(label="Open", command=self.browse_directory)
        subMenu.add_command(label="Add Directory", command=self.add_directory)
        subMenu.add_command(label="Load Directories", command=self.load_directories)
        subMenu.add_separator()
        subMenu.add_command(label="Save Playlist", command=self.save_playlist)
        subMenu.add_command(label="Load Playlist", command=self.load_playlist)
        subMenu.add_command(label="Delete Playlist", command=self.delete_playlist)
        subMenu.add_command(label="Clear Playlist", command=self.clear_playlistbox)
        subMenu.add_separator()
        subMenu.add_command(label="Exit", command= lambda: self.on_closing(top))

        subMenu0 = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Settings", menu=subMenu0)
        subMenu0.add_command(label="Change Name", command=self.change_nickname)
        
        subMenu1 = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label='Help', menu=subMenu1)
        subMenu1.add_command(label='About Us', command=self.about_us)


        self.btn_stop = ttk.Button(top, command=self.stop)
        self.btn_stop.place(relx=0.55, rely=0.497, height=45, width=96)
        self.btn_stop.configure(takefocus="")
        self.btn_stop.configure(text=' ❌ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_stop, tooltip_font, 'Stop', delay=0.5)

        self.btn_play_pause = ttk.Button(top, command=self.play_pause)
        self.btn_play_pause.place(relx=0.384, rely=0.497, height=45, width=96)
        self.btn_play_pause.configure(takefocus="")
        self.btn_play_pause.configure(text=' ᢰ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_play_pause, tooltip_font, 'Play', delay=0.5)
        

        self.btn_skip_back = ttk.Button(top, command=self.go_back)
        self.btn_skip_back.place(relx=0.217, rely=0.497, height=45, width=96)
        self.btn_skip_back.configure(takefocus="")
        self.btn_skip_back.configure(text=' ᢲ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_skip_back, tooltip_font, 'Skip to Beginning', delay=0.5)
        

        self.btn_skip_fore = ttk.Button(top, command = self.go_to_next)
        self.btn_skip_fore.place(relx=0.716, rely=0.497, height=45, width=86)
        self.btn_skip_fore.configure(takefocus="")
        self.btn_skip_fore.configure(text=' ᢶ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_skip_fore, tooltip_font, '''Skip to Next''', delay=0.5)

        

        self.frm_net_stat = tk.Frame(top)
        self.frm_net_stat.place(relx=0.499, rely=0.663, relheight=0.155
                , relwidth=0.096)
        self.frm_net_stat.configure(relief='groove')
        self.frm_net_stat.configure(borderwidth="2")
        self.frm_net_stat.configure(relief="groove")
        self.frm_net_stat.configure(background="#d9d9d9")
        self.frm_net_stat.configure(highlightbackground="#d9d9d9")
        self.frm_net_stat.configure(highlightcolor="black")
        self.frm_net_stat.configure(width=75)

        #import icons
        try:
            net_off_img_loc = os.path.join(self.dir_path, 'img', 'net_off_nb.png')
            net_on_img_loc = os.path.join(self.dir_path, 'img', 'net_on_nb.png')
            self.net_off_img = tk.PhotoImage(file = net_off_img_loc)
            self.net_on_img = tk.PhotoImage(file = net_on_img_loc)
            self.net_status = tk.Label(self.frm_net_stat, image = self.net_off_img)
        except:
            print('could not find icons')
            self.net_status = tk.Label(self.frm_net_stat)
        self.net_status.place(relx=0.133, rely=0.133, height=61, width=54)
        self.net_status.configure(activebackground="#f9f9f9")
        self.net_status.configure(activeforeground="black")
        self.net_status.configure(background="#d9d9d9")
        self.net_status.configure(disabledforeground="#a3a3a3")
        self.net_status.configure(foreground="#000000")
        self.net_status.configure(highlightbackground="#d9d9d9")
        self.net_status.configure(highlightcolor="black")
        self.net_status.configure(text='status')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.net_status, tooltip_font, 'Connection Status', delay=0.5)

        self.btn_add_file = ttk.Button(top, command=self.browse_file)
        self.btn_add_file.place(relx=0.038, rely=0.124, height=55, width=56)
        self.btn_add_file.configure(takefocus="")
        self.btn_add_file.configure(text=' + ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_add_file, tooltip_font, 'Add a song from file', delay=0.5)

        self.btn_del_file = ttk.Button(top, command=self.del_song)
        self.btn_del_file.place(relx=0.038, rely=0.373, height=55, width=56)
        self.btn_del_file.configure(takefocus="")
        self.btn_del_file.configure(text='''-''')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_del_file, tooltip_font, 'Remove selected file from list', delay=0.5)
        #Mute
        self.btn_mute = ttk.Button(top, command = self.mute_music)
        self.btn_mute.place(relx=0.038, rely=0.704, height=65, width=46)
        self.btn_mute.configure(takefocus="")
        self.btn_mute.configure(text=' ᚡ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_mute, tooltip_font, 'Mute', delay=0.5)
        

        self.TSeparator1 = ttk.Separator(top)
        self.TSeparator1.place(relx=0.026, rely=0.104, relheight=0.745)
        self.TSeparator1.configure(orient="vertical")

        self.btn_shuffle = ttk.Button(top, command=self.shuffle)
        self.btn_shuffle.place(relx=0.038, rely=0.248, height=55, width=56)
        self.btn_shuffle.configure(takefocus="")
        self.btn_shuffle.configure(text=''' ↭ ''')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_shuffle, tooltip_font, 'Shuffle', delay=0.5)

        self.btn_stream = ttk.Button(top, command=self.stream)
        self.btn_stream.place(relx=0.499, rely=0.828, height=45, width=76)
        self.btn_stream.configure(takefocus="")
        self.btn_stream.configure(text=' ᦰ ')
        tooltip_font = "TkDefaultFont"
        ToolTip(self.btn_stream, tooltip_font, 'Stream', delay=0.5)

        #Volume
        self.scale_vol = ttk.Scale(top, from_=1.0, to=0, command=self.set_vol)
        self.scale_vol.place(relx=0.115, rely=0.683, relwidth=0.0
                , relheight=0.207, width=26, bordermode='ignore')
        self.scale_vol.configure(orient="vertical")
        self.scale_vol.configure(takefocus="")
        self.scale_vol.set(.7)

        self.frame_network = tk.Frame(top)
        self.frame_network.place(relx=0.601, rely=0.621, relheight=0.321
                , relwidth=0.377)
        self.frame_network.configure(relief='groove')
        self.frame_network.configure(borderwidth="2")
        self.frame_network.configure(relief="groove")
        self.frame_network.configure(background="#d9d9d9")
        self.frame_network.configure(highlightbackground="#d9d9d9")
        self.frame_network.configure(highlightcolor="black")
        self.frame_network.configure(width=295)

        self.devices_listbox = tk.Listbox(self.frame_network)
        self.devices_listbox.place(relx=0.034, rely=0.258, relheight=0.658
                , relwidth=0.793)
        self.devices_listbox.configure(selectmode=tk.MULTIPLE)
        self.devices_listbox.configure(exportselection=False)
        self.devices_listbox.configure(background="white")
        self.devices_listbox.configure(disabledforeground="#a3a3a3")
        self.devices_listbox.configure(font="TkFixedFont")
        self.devices_listbox.configure(foreground="#000000")
        self.devices_listbox.configure(highlightbackground="#d9d9d9")
        self.devices_listbox.configure(highlightcolor="black")
        self.devices_listbox.configure(relief="flat")
        self.devices_listbox.configure(selectbackground="#c4c4c4")
        self.devices_listbox.configure(selectforeground="black")
        self.devices_listbox.configure(width=234)

        self.lbl_net = tk.Label(self.frame_network)
        self.lbl_net.place(relx=0.034, rely=0.065, height=21, width=164)
        self.lbl_net.configure(activebackground="#f9f9f9")
        self.lbl_net.configure(activeforeground="black")
        self.lbl_net.configure(anchor='w')
        self.lbl_net.configure(background="#d9d9d9")
        self.lbl_net.configure(disabledforeground="#a3a3a3")
        self.lbl_net.configure(font="-family {Yu Gothic UI} -size 13")
        self.lbl_net.configure(foreground="#000000")
        self.lbl_net.configure(highlightbackground="#d9d9d9")
        self.lbl_net.configure(highlightcolor="black")
        self.lbl_net.configure(text='''Networked Devices''')

        self.network_scroll = tk.Scrollbar(self.frame_network)
        self.network_scroll.place(relx=0.847, rely=0.258, relwidth=0.0
                , relheight=0.645, width=38, bordermode='ignore')
        self.network_scroll.configure(background="#d9d9d9")
        self.network_scroll.configure(highlightcolor="black")
        self.network_scroll.configure(troughcolor="#d9d9d9")
        self.network_scroll.configure(width=30)
        #attach scroll to box
        self.network_scroll.config(command=self.devices_listbox.yview) 
        self.devices_listbox.config(yscrollcommand=self.network_scroll.set)
        #
        
        self.frm_playlist = tk.Frame(top)
        self.frm_playlist.place(relx=0.128, rely=0.062, relheight=0.424
                , relwidth=0.85)
        self.frm_playlist.configure(relief='groove')
        self.frm_playlist.configure(borderwidth="2")
        self.frm_playlist.configure(relief="groove")
        self.frm_playlist.configure(background="#d9d9d9")
        self.frm_playlist.configure(highlightbackground="#d9d9d9")
        self.frm_playlist.configure(highlightcolor="black")
        self.frm_playlist.configure(width=665)

        self.lbl_playlist = tk.Label(self.frm_playlist)
        self.lbl_playlist.place(relx=0.015, rely=0.049, height=21, width=74)
        self.lbl_playlist.configure(activebackground="#f9f9f9")
        self.lbl_playlist.configure(activeforeground="black")
        self.lbl_playlist.configure(anchor='w')
        self.lbl_playlist.configure(background="#d9d9d9")
        self.lbl_playlist.configure(disabledforeground="#a3a3a3")
        self.lbl_playlist.configure(font="-family {Yu Gothic UI} -size 13")
        self.lbl_playlist.configure(foreground="#000000")
        self.lbl_playlist.configure(highlightbackground="#d9d9d9")
        self.lbl_playlist.configure(highlightcolor="black")
        self.lbl_playlist.configure(text='''Playlist''')

        #Search
        self.searchParam = tk.StringVar()
        self.searchParam.trace('w', self.searchList)
        self.searchbox = tk.Entry(self.frm_playlist)
        self.searchbox.place(relx=0.496, rely=0.049,height=20, relwidth=0.412)
        self.searchbox.configure(textvariable = self.searchParam)
        self.searchbox.configure(background="white")
        self.searchbox.configure(disabledforeground="#a3a3a3")
        self.searchbox.configure(font="TkFixedFont")
        self.searchbox.configure(foreground="#000000")
        self.searchbox.configure(highlightbackground="#d9d9d9")
        self.searchbox.configure(highlightcolor="black")
        self.searchbox.configure(insertbackground="black")
        self.searchbox.configure(relief="flat")
        self.searchbox.configure(selectbackground="#c4c4c4")
        self.searchbox.configure(selectforeground="black")
        #self.searchbox.bind('<<FocusIn>>', self.clear_box)
        tooltip_font = "TkDefaultFont"
        ToolTip(self.searchbox, tooltip_font, '''Search Bar''', delay=0.5)

        self.lbl_search = tk.Label(self.frm_playlist)
        self.lbl_search.place(relx=0.406, rely=0.049, height=21, width=64)
        self.lbl_search.configure(activebackground="#f9f9f9")
        self.lbl_search.configure(activeforeground="black")
        self.lbl_search.configure(anchor='w')
        self.lbl_search.configure(background="#d9d9d9")
        self.lbl_search.configure(disabledforeground="#a3a3a3")
        self.lbl_search.configure(font="-family {Yu Gothic UI} -size 13")
        self.lbl_search.configure(foreground="#000000")
        self.lbl_search.configure(highlightbackground="#d9d9d9")
        self.lbl_search.configure(highlightcolor="black")
        self.lbl_search.configure(text='''Search''')

        self.playlistbox = tk.Listbox(self.frm_playlist)
        self.playlistbox.place(relx=0.015, rely=0.195, relheight=0.741
                , relwidth=0.908)
        self.playlistbox.configure(background="white")
        self.playlistbox.configure(disabledforeground="#a3a3a3")
        self.playlistbox.configure(font="TkFixedFont")
        self.playlistbox.configure(foreground="#000000")
        self.playlistbox.configure(highlightbackground="#d9d9d9")
        self.playlistbox.configure(highlightcolor="black")
        self.playlistbox.configure(relief="flat")
        self.playlistbox.configure(selectbackground="#c4c4c4")
        self.playlistbox.configure(selectforeground="black")
        self.playlistbox.configure(width=604)

        self.playlist_scroll = tk.Scrollbar(self.frm_playlist)
        self.playlist_scroll.place(relx=0.932, rely=0.195, relwidth=0.0
                , relheight=0.741, width=38, bordermode='ignore')
        self.playlist_scroll.configure(background="#d9d9d9")
        self.playlist_scroll.configure(troughcolor="#d9d9d9")
        self.playlist_scroll.configure(width=30)
        #attach scroll to box
        self.playlist_scroll.config(command=self.playlistbox.yview) 
        self.playlistbox.config(yscrollcommand=self.playlist_scroll.set)
        #New Feat (time and tracking)
        
        self.frm_new_feat = tk.Frame(top)
        self.frm_new_feat.place(relx=0.166, rely=0.621, relheight=0.321
                , relwidth=0.313)
        self.frm_new_feat.configure(relief='groove')
        self.frm_new_feat.configure(borderwidth="2")
        self.frm_new_feat.configure(relief="groove")
        self.frm_new_feat.configure(background="#d9d9d9")
        self.frm_new_feat.configure(highlightbackground="#d9d9d9")
        self.frm_new_feat.configure(highlightcolor="black")
        self.frm_new_feat.configure(width=245)

        self.lengthlabel = ttk.Label(self.frm_new_feat, text='Total Length : --:--')
        self.lengthlabel.pack(pady=5)

        self.currenttimelabel = ttk.Label(self.frm_new_feat, text='Current Time : --:--')
        self.currenttimelabel.pack()

        self.trackbar = ttk.Scale(self.frm_new_feat, from_=0, to=0, orient=tk.HORIZONTAL)
        self.trackbar.configure(command=self.set_track)
        self.trackbar.pack()

        #final prep
        self.stream_control_window = None
        self.load_settings()
        self.autoload_playlist()
        self.network_thread = threading.Thread(target = self.net_status_update)
        self.network_thread.start()
        self.threads.append(self.network_thread)
        self.remote_monitor_thread = threading.Thread(target = self.remote_play_monitor)
        self.remote_monitor_thread.start()
        self.threads.append(self.remote_monitor_thread)
        
        #begin monitoring
        self.monitor_thread = threading.Thread(target = self.monitor)
        self.monitor_thread.start()
        self.threads.append(self.monitor_thread)
        
    #settings
    def load_settings(self):
        print('loading settings')
        try:
            with open(self.settings_file_loc, "rb") as in_file:
                self.settings = pickle.load(in_file)
            info = self.infoQ.get()
            if 'name' in self.settings:
                #print('device name',self.settings['name'],'used')
                info['deviceName'] = self.settings['name']
            self.infoQ.put(info)
        except IOError:
            pass#no settings file
         
    def save_settings(self):
        print('saving settings')
        with open(self.settings_file_loc, "wb") as out_file:
            pickle.dump(self.settings, out_file)

    def change_nickname(self):
         self.settings['name'] = simpledialog.askstring('Device Name','What would you like to call this player?')
         print('name changed to',self.settings['name'])
         self.save_settings()
        
    #Search
    def clear_box(self):
        #print('clear')
        self.searchbox.delete(0,'end')
        
    def searchList(self,p0,p1,p2):
        param = str(self.searchbox.get())
        if param == '':
            pass
        else:
            titles = []
            reference = {}
            size = self.playlistbox.size()
            for i in range(size):
                title = self.playlistbox.get(i)
                reference[title] = i
                titles.append(title)
            #print(param)
            best = difflib.get_close_matches(word = param,possibilities = titles,n = 1, cutoff = .2)
            #print (best)
            if len(best)>0:
                at = reference[best[0]]
                #print(best, at)
                self.playlistbox.see(at)
                self.playlistbox.selection_clear(0,size)
                self.playlistbox.selection_set(at)
        
    #Monitor (background tasks)
    def monitor(self):
        #TODO: periodic network rescan
        #print('busy',self.busy.is_set())
        while not self.shutdown.is_set():
            self.busy.wait()
            #save playlist for next time
            try:
                with open(self.dir_file_loc, "r") as dir_file:
                    for dir_loc in dir_file:
                        for fn in os.listdir(dir_loc):
                            parsed_name=fn.split('.')
                            if len(parsed_name) == 2:
                                if parsed_name[1] == 'mp3':
                                    self.playlist[parsed_name[0]] = os.path.join(dir_loc, fn)
            except IOError:
                #print('no assosiated directory')
                pass
            #keep playlist saved
            try:
                self.save_playlist(self.lastList_file_loc)
            except IOError:
                #print('no assosiated directory')
                pass
            except RuntimeError:
                pass #likly exited program
            
            #print('monitor has infoQ')
            sleep(15)      
            
    #Network     
    # def stream_next_monitor(self):
    #     self.stream_next.wait()
    #     self.stream_go_to_next()

    def remote_play_monitor(self):
        while not self.shutdown.is_set():
            self.busy.wait()
            self.remote_play_event.wait() #changed from if
            self.busy.clear() 
            if self.req_remote == False:#if not internally requested
                self.statusbar['text'] = 'Remote Playing'
                ans = tk.messagebox.askyesno("Remote Play",
                    "This player is being controlled from another location."+
                    "\n Do you want control back?")
                if ans:
                    self.req_remote = False
                    print("user took control")
                    self.remote_play_event.clear()

            self.busy.set()

            sleep(10)
                      
    def net_status_update(self):
        while not self.shutdown.is_set():
            try:
                #print('check stat')
                self.network.ready.wait() 
                self.net_rdy = True
                if self.net_on_img is not None:
                    self.net_status.config(image = self.net_on_img)
                for addr in self.network.addr_list:
                    print('found', addr)
                    recv_data = self.network.recvQ.get()
                    print('recieved:',recv_data[addr]['deviceName'][0])
                    deviceName = recv_data[addr]['deviceName'][0]
                    if deviceName == '':
                        deviceName = addr
                    self.add_to_netlist(deviceName, addr)
                    print('recieved:',recv_data[addr]['titleList'])
                    titleList = recv_data[addr]['titleList']
                    self.network.recvQ.put(recv_data)
                    self.add_to_playlist_remote(deviceName,addr,titleList)
                break
                #else:
                    #TODO: no net icon
                    #tkinter.messagebox.showinfo('Network', 'Could not find network!')
            except RuntimeError:
                print(RuntimeError)
                pass #thread hasn't statrted
        #happens after established connection
        print('net rdy')
        while not self.shutdown.is_set():
            self.busy.wait()
            info = self.serverQ.get()#get remote play requests
            if len(info['requests'])>0:
                print('the request->',info['requests'])
                title = info['requests'][0][1]#the title
                self.stream(title)
                info['requests'] = info['requests'][1:]
            self.serverQ.put(info)
            
            recv_data = self.network.recvQ.get()
            #print('recv_data',recv_data)
            for kAddr in recv_data:
                addr = str(kAddr)
                deviceName = recv_data[kAddr]['deviceName'][0]
                if deviceName == '':
                    deviceName = addr
                # print(str(kAddr), deviceName)
                if deviceName not in self.devicelist:
                    if addr not in self.network.addr_list:
                        self.network.addr_list.append(addr)
                    self.devicelist[deviceName] = addr
                    print('adding', deviceName)
                    self.add_to_netlist(deviceName, addr)
                #check for new titles
                titleList = recv_data[addr]['titleList']
                self.add_to_playlist_remote(deviceName,addr,titleList)
            self.network.recvQ.put(recv_data)

            remlist = []
            rem_at_list = []

            for kName in self.devicelist:
                deviceName = str(kName)
                addr = self.devicelist[kName]
                if addr not in self.network.addr_list:
                    remlist.append(kName)
                    size = self.devices_listbox.size()
                    for iDevice in range(size):
                        device = self.devices_listbox.get(iDevice)
                        if deviceName == device:
                            rem_at_list.append(iDevice)
                            break
            for kName in remlist:
                size = self.playlistbox.size()
                remove_title_at = []
                for iTitle in range(size):#find all titles from remote device
                    title = self.playlistbox.get(iTitle)
                    if '<- '+str(kName) in title:
                        remove_title_at.append(iTitle)
                        del self.playlist[title]#remove the address refrence so it can come from elsewhere
                for iTitle in remove_title_at: 
                    self.playlistbox.delete(iTitle) #and remove them
                
                if remlist is not []:
                    print ('rl',remlist)
                del self.devicelist[kName] #also remove device form device list
            for iDevice in rem_at_list:
                if rem_at_list is not []:
                    print ('ral',rem_at_list)
                self.devices_listbox.delete(iDevice) #and remove it from the device box
        sleep(120)          

    def add_to_netlist(self, deviceName, addr):
        self.devicelist[deviceName] = addr
        index = self.devices_listbox.size()
        self.devices_listbox.insert(index, deviceName)

    def clean_netlist(self):
        for i in range(self.devices_listbox.size()):
            if self.devicelist[self.devices_listbox.get(i)] not in self.network.addr_list:
                self.devices_listbox.delete(i)
        
    def stream(self, selected_song =''):
        if selected_song == '':
            selected_song = self.playlistbox.curselection()
            selected_song = int(selected_song[0])
            stream_it = self.playlist[self.playlistbox.get(selected_song)]
        else:
            stream_it = self.playlist[selected_song]
        print('streaming', stream_it)
        threading.Thread(target=self.send_song_to_all, args=[stream_it]).start()

    def send_mult_file(self, binary_array):
        addr_list = []
        selection = self.devices_listbox.curselection()
        for i in selection:
            #print('devicelist',self.devicelist,'i', self.devices_listbox.get(i))
            addr = self.devicelist[self.devices_listbox.get(i)]
            addr_list.append(addr)
        if addr_list == []:
            print('sending mfile to all')
            self.network.send_serialized_to_all_m(binary_array, True)
        else:  
            print('sending mfile to specific')
            self.network.send_serialized_to_specific(addr_list, binary_array, True)
        
        
    def send_song_to_all(self,path):
        self.busy.clear()
        print('busy clear')
        self.statusbar['text'] = 'Remote Playing'
        with open(path, "rb") as file:
            fn = os.path.basename(path)
            info = fmt.get(file.read(128))
            if info.extension != [] and info.extension[0] == 'mp3':
                print('starting segmentation')
                segment = AudioSegment.from_mp3(path)
                print(fn, path, len(segment), 'ms')
                slices = []
                for sslice in range(0, len(segment), 5000):
                    temp_name = os.path.join(self.dir_path,'temp',fn[:-4]+'.wav')
                    segment[sslice:sslice+5000].export(temp_name, format="wav")    
                    sound = mixer.Sound(file = temp_name)
                    #print(sys.getsizeof(sound.get_raw()))
                    data = zlib.compress(sound.get_raw(), 9)
                    #print(sys.getsizeof(data))
                    #data = sound.get_raw()
                    slices.append(data)
                    os.remove(temp_name)
                self.send_mult_file(slices)
        self.busy.set()
        print('busy set')

    #Playlist Management
    def save_playlist(self, path = ''):
        exists = False
        suffix = '.dat'
        if path == '':
            name = simpledialog.askstring('Save Name','What would you like to call the playlist?')
            if name != '' and name != None:
                for char in ['\\','/',':','*','?','\"','<','>','|']:
                    name=name.strip(char)
                path=os.path.join(self.pList_file_loc, name+suffix)
                print(path)
                #check for existance of file name
                if name+suffix == self.dir_file_name:
                    exists = True
                    tkinter.messagebox.showinfo('Reserved Name',
                        'This name is reserved for internal use.\nPlease choose another name')
                for fn in os.listdir(self.pList_file_loc):
                    if fn == name + suffix:
                        exists = True
                        tkinter.messagebox.showinfo('Already Exisits',
                            'This name is already associated.\nPlease choose another name')
                        break
        #save list
        if exists == False:
            save_list = {}
            size = self.playlistbox.size()
            for iTitle in range(size):
                title = self.playlistbox.get(iTitle)
                if title is not '':
                    #print (self.playlist)
                    save_list[title] = self.playlist[title]
            if path is not '':
                with open(path, "wb") as out_file:
                    pickle.dump(save_list, out_file)
                    #print('saved', path)
                
    def autoload_playlist(self):#for loading last list on open
        try:
            #print('autoload')
            with open(self.lastList_file_loc, "rb") as in_file:
                last_list = pickle.load(in_file)
                #self.playlist.update(last_list) #update in case new info (prolly not the case)
                #print(playlist)
                self.add_from_playlist(last_list) #we only want to load the last songs
        except FileNotFoundError:
            self.playlist={}
            #pass #file doesn not exist yet
            #print('autoload fail')
        except EOFError:
            self.playlist={} #write likley interrupted

    
    def load_playlist(self):
        try:
            self.load_window.destroy() #in case the user has another open
        except AttributeError:
            pass #the user didn't have one open
        
        self.load_window = tk.Toplevel()
        lbl_load = tk.Label(self.load_window, text = 'Select playlist to load')
        lbl_load.pack()
        self.loadlistbox = tk.Listbox(self.load_window)
        self.loadlistbox.pack()
        #find all names
        for fn in os.listdir(self.pList_file_loc):
            if fn not in self.non_user_data_names: #don't want user access to these data files
                index = self.loadlistbox.size()
                name = fn.split('.')
                if len(name) == 2 and name[1] == 'dat':
                    self.loadlistbox.insert(index, name[0]) 
        btn_select = ttk.Button(self.load_window, command=self.open_chosen)
        btn_select.configure(text = 'Select')
        btn_select.pack()

    def open_chosen(self):
        selected_list = self.loadlistbox.curselection()
        #print(self.dir_file_name)
        if selected_list is not ():
            selected_list = int(selected_list[0])
            try:
                self.playlist_name = self.loadlistbox.get(selected_list)
                print(self.playlist_name, selected_list)
                path=os.path.join(self.pList_file_loc, self.playlist_name+'.dat')
                print(path)
                with open(path, "rb") as in_file:
                    playlist = pickle.load(in_file)
                    #print(playlist)
                self.clear_playlistbox()
                self.add_from_playlist(playlist)
            except FileNotFoundError:
                pass #file does not exist yet
                print('Cant load list')
        self.load_window.destroy()

    def delete_playlist(self):
        self.load_window = tk.Toplevel()
        lbl_load = tk.Label(self.load_window, text = 'Select playlist to delete')
        lbl_load.pack()
        self.loadlistbox = tk.Listbox(self.load_window)
        self.loadlistbox.pack()
        #find all names
        for fn in os.listdir(self.pList_file_loc):
            if fn not in self.non_user_data_names: #don't want user access to these data files
                index = self.loadlistbox.size()
                name = fn.split('.')
                if len(name) == 2 and name[1] == 'dat':
                    self.loadlistbox.insert(index, name[0]) 
        btn_select = ttk.Button(self.load_window, command=self.delete_chosen)
        btn_select.configure(text = 'Select')
        btn_select.pack()
        
    def delete_chosen(self):
        selected_list = self.loadlistbox.curselection()
        #print(self.dir_file_name)
        if selected_list is not ():
            selected_list = int(selected_list[0])
            try:
                playlist_name = self.loadlistbox.get(selected_list)
                print(playlist_name, selected_list)
                path=os.path.join(self.pList_file_loc, playlist_name+'.dat')
                print(path)
                MsgBox = tk.messagebox.askquestion ('Delete List',
                        'Are you sure you want to\ndelete '+ playlist_name + '?',icon = 'warning')
                if MsgBox == 'yes':
                   os.remove(path)
                
            except FileNotFoundError:
                pass #file does not exist yet
                print('Cant delete list')
        self.load_window.destroy()

    #tells remote clients whats availale on our system
    def update_titles(self): 
        #infoQ contains netList|titleList|fileTitle(if streaming)
        try:
            with open(self.dir_file_loc, "r") as dir_file:
                for dir_loc in dir_file:
                    if dir_loc is not '':
                        for fn in os.listdir(dir_loc):
                            parsed_name=fn.split('.')
                            if len(parsed_name) == 2:
                                if parsed_name[1] == 'mp3':
                                    #print('update_titles',os.path.join(dir_loc,fn))
                                    filename_path = os.path.join(dir_loc,fn)
                                    try:
                                        tags = ID3(filename_path)
                                        title = str(tags["TPE1"]) + ' - ' + str(tags["TIT2"])
                                    except ID3NoHeaderError:
                                        title = os.path.basename(filename_path)
                                    except KeyError:
                                        title = os.path.basename(filename_path)
                                    if title not in self.playlist:
                                        self.playlist[title] = filename_path #so we know where it is
        except FileNotFoundError:
            print('file not found')
            

        info = self.infoQ.get()
        kTitles_to_send = []
        for kTitle in self.playlist.keys():
            if self.playlist[kTitle][0] is not '&':
                kTitles_to_send.append(kTitle)
        info['titleList'] = kTitles_to_send #update title list (out)
        self.infoQ.put(info)
        
        #print('monitor dropped infoQ')

    #File I/O
    def del_diretories(self):
        True
        #tkinter.messagebox.showinfo('Tricky',
                    #       'This can be done by modifying the file')
    def load_directories(self):
        try:
            with open(self.dir_file_loc, "r") as dir_file:
                for dir_loc in dir_file:
                    self.clear_playlistbox()
                    self.browse_directory(dir_loc)
        except FileNotFoundError:
            print('file not found')
            self.add_directory()#direct user to add directories
            
    def add_directory(self):
        exists = False
        folder_selected = self.browse_directory()
        try:
            with open(self.dir_file_loc, "r") as dir_file:
                for dir_loc in dir_file:
                    if dir_loc == folder_selected:
                        exists = True
                        #tkinter.messagebox.showinfo('Already Exisits',
                        #       'This file is already associated.\nPlease use \'Load Directories\' option')
                        break
        except FileNotFoundError:
            pass #file not created yet
        if exists == False:
            with open(self.dir_file_loc, "w") as dir_file:
                dir_file.write(folder_selected)
            #print(folder_selected)
        self.update_titles()#updates titles available for remote clients
        
    def browse_directory(self, folder_selected = ''):
        if folder_selected == '':
            folder_selected = filedialog.askdirectory()
        if folder_selected is not '':
            try:
                for fn in os.listdir(folder_selected):
                    parsed_name=fn.split('.')
                    if len(parsed_name) == 2:
                        if parsed_name[1] == 'mp3':
                            print(os.path.join(folder_selected,fn))
                            self.add_to_playlist(os.path.join(folder_selected,fn))
            except IOError:
                tkinter.messagebox.showerror('Error', 'Could not open the folder, please check and try again.')
        return folder_selected
    
    def browse_file(self):
        try:
            #restrict to acceptable types
            fTypes = [('mp3 files','*.mp3'),('wave files','*.wav')]
            filename_path = filedialog.askopenfilename(filetypes=fTypes)
        except IOError:
            tkinter.messagebox.showerror('Error', 'Could not open the file, please check and try again.')
            self.stop()
        if filename_path is not '':
            parsed_name=filename_path.split('.')
            if len(parsed_name) == 2:
                #fn = os.path.basename(filename_path)
                self.add_to_playlist(filename_path)
                mixer.music.queue(filename_path)

    def clear_playlistbox(self):
        size = self.playlistbox.size()
        self.playlistbox.delete(0,size)

    def add_to_playlist_remote(self, deviceName, addr, titleList):
        #print('add to playlist remote called', titleList)
        for title in titleList:
            in_playlistbox = False
            size = self.playlistbox.size()
            for iTitle in range(size):
                pl_title = self.playlistbox.get(iTitle)
                if title is pl_title:
                    in_playlistbox = True
                    break
            if not in_playlistbox: #if its not already local
                add_title = title + ' <- ' + deviceName #TODO: way to check if its here from another machine (use lsit comp)
                if add_title not in self.playlist:
                    index = self.playlistbox.size()
                    self.playlistbox.insert(index, title + ' <- ' + deviceName)
                    self.playlist[title + ' <- ' + deviceName] = '&'+addr
        
    def add_to_playlist(self, filename_path):
        try:
            tags = ID3(filename_path)
            title = str(tags["TPE1"]) + ' - ' + str(tags["TIT2"])
        except ID3NoHeaderError:
            title = os.path.basename(filename_path)
        except KeyError:
            title = os.path.basename(filename_path)
        #if title not in self.playlist:
        index = self.playlistbox.size()
        self.playlistbox.insert(index, title)
        self.playlist[title] = filename_path

    def add_from_playlist(self, playlist = {}):
        deleteList = []
        for kTitle in playlist.keys():
            title = str(kTitle)
            if playlist[kTitle][0] is not '&': #not remote
                index = self.playlistbox.size()
                self.playlistbox.insert(index, title)
                if title not in self.playlist:
                    self.playlist[title] = playlist[kTitle]
            else: #if remote
                if playlist[kTitle][1:] in self.network.addr_list:
                    index = self.playlistbox.size()
                    self.playlistbox.insert(index, title)
                    if title not in self.playlist:
                        self.playlist[title] = playlist[kTitle]   
                else:
                    print('skipped', kTitle)
                    deleteList.append(kTitle)
        for kTitle in deleteList:
            del playlist[kTitle] #remove it so it does not block new entries

    def del_song(self):
        selected_song = self.playlistbox.curselection()
        if selected_song is not ():
            selected_song = int(selected_song[0])
            try:
                self.playlistbox.delete(selected_song)
            except Exception:
                print(Exception)
                
    #Help
    def about_us(self):
        tkinter.messagebox.showinfo('About DMP', 'This is a music player build using Python Tkinter by Jon L. Battison')
    #Song Info & Tracking
    def set_track(self, val):
        if not self.adj_bar:
            print(val, self.current_time)
        True
        
    def show_details(self,play_song, pos):
        file_data = os.path.splitext(play_song)

        if file_data[1] == '.mp3':
            audio = MP3(play_song)
            total_length = audio.info.length
        else:
            a = mixer.Sound(play_song)
            total_length = a.get_length()

        # div - total_length/60, mod - total_length % 60
        mins, secs = divmod(total_length, 60)
        mins = round(mins)
        secs = round(secs)
        self.timeformat = '{:02d}:{:02d}'.format(mins, secs)
        self.lengthlabel['text'] = "Total Length" + ' - ' + self.timeformat

        t1 = threading.Thread(target=self.start_count, args=[total_length, pos])
        t1.start()

    def start_count(self,t, pos):
        self.trackbar.configure(to = t)
        # mixer.music.get_busy(): - Returns FALSE when we press the stop button (music stop playing)
        # Continue - Ignores all of the statements below it. We check if music is paused or not.
        self.current_time = pos
        while self.current_time <= t and mixer.music.get_busy():
            if self.paused:
                continue
            else:
                self.adj_bar = True
                self.trackbar.set(self.current_time)
                self.adj_bar = False
                mins, secs = divmod(self.current_time, 60)
                mins = round(mins)
                secs = round(secs)
                self.timeformat = '{:02d}:{:02d}'.format(mins, secs)
                self.currenttimelabel['text'] = "Current Time" + ' - ' + self.timeformat
                sleep(1)
                self.current_time += 1
        print(self.current_time,'>=', t-1 )
        if self.current_time >= t-1:
            sleep(1)
            self.go_to_next()
        
    #Controls
    # def launch_stream_controls(self):
    #     #hold launch device name
    #     self.stream_control_window_open = True
    #     self.stream_control_window = tk.Toplevel()
    #     self.stream_control_window.geometry("449x133+544+340")
    #     self.stream_control_window.title(self.request_from_name)
    #     self.stream_control_window.configure(background="#d9d9d9")
        
    #     self.stream_btn_skip_back = tk.Button(self.stream_control_window, command = self.stream_go_back)
    #     self.stream_btn_skip_back.place(relx=0.045, rely=0.301, height=44, width=87)
    #     self.stream_btn_skip_back.configure(activebackground="#ececec")
    #     self.stream_btn_skip_back.configure(activeforeground="#000000")
    #     self.stream_btn_skip_back.configure(background="#d9d9d9")
    #     self.stream_btn_skip_back.configure(disabledforeground="#a3a3a3")
    #     self.stream_btn_skip_back.configure(foreground="#000000")
    #     self.stream_btn_skip_back.configure(highlightbackground="#d9d9d9")
    #     self.stream_btn_skip_back.configure(highlightcolor="black")
    #     self.stream_btn_skip_back.configure(pady="0")
    #     self.stream_btn_skip_back.configure(width=87)
    #     self.stream_btn_skip_back.configure(text=' ᢲ ')

    #     self.stream_btn_play_pause = tk.Button(self.stream_control_window, command = self.stream_play_pause)
    #     self.stream_btn_play_pause.configure(text=' ነ ')
    #     self.stream_btn_play_pause.place(relx=0.29, rely=0.301, height=44, width=87)
    #     self.stream_btn_play_pause.configure(activebackground="#ececec")
    #     self.stream_btn_play_pause.configure(activeforeground="#000000")
    #     self.stream_btn_play_pause.configure(background="#d9d9d9")
    #     self.stream_btn_play_pause.configure(disabledforeground="#a3a3a3")
    #     self.stream_btn_play_pause.configure(foreground="#000000")
    #     self.stream_btn_play_pause.configure(highlightbackground="#d9d9d9")
    #     self.stream_btn_play_pause.configure(highlightcolor="black")
    #     self.stream_btn_play_pause.configure(pady="0")
    #     self.stream_btn_play_pause.configure(width=87)
    
    #     self.stream_btn_stop = tk.Button(self.stream_control_window, command = self.stream_stop)
    #     self.stream_btn_stop.place(relx=0.535, rely=0.301, height=44, width=87)
    #     self.stream_btn_stop.configure(activebackground="#ececec")
    #     self.stream_btn_stop.configure(activeforeground="#000000")
    #     self.stream_btn_stop.configure(background="#d9d9d9")
    #     self.stream_btn_stop.configure(disabledforeground="#a3a3a3")
    #     self.stream_btn_stop.configure(foreground="#000000")
    #     self.stream_btn_stop.configure(highlightbackground="#d9d9d9")
    #     self.stream_btn_stop.configure(highlightcolor="black")
    #     self.stream_btn_stop.configure(pady="0")
    #     self.stream_btn_stop.configure(width=87)
    #     self.stream_btn_stop.configure(text=' ❌ ')

    #     self.stream_btn_skip_fore = tk.Button(self.stream_control_window, command = self.stream_go_to_next)
    #     self.stream_btn_skip_fore.place(relx=0.78, rely=0.301, height=44, width=87)
    #     self.stream_btn_skip_fore.configure(activebackground="#ececec")
    #     self.stream_btn_skip_fore.configure(activeforeground="#000000")
    #     self.stream_btn_skip_fore.configure(background="#d9d9d9")
    #     self.stream_btn_skip_fore.configure(disabledforeground="#a3a3a3")
    #     self.stream_btn_skip_fore.configure(foreground="#000000")
    #     self.stream_btn_skip_fore.configure(highlightbackground="#d9d9d9")
    #     self.stream_btn_skip_fore.configure(highlightcolor="black")
    #     self.stream_btn_skip_fore.configure(pady="0")
    #     self.stream_btn_skip_fore.configure(width=87)
    #     self.stream_btn_skip_fore.configure(text=' ᢶ ')

    #     #Hold title of song
    #     self.lblTitle = tk.Label(self.stream_control_window)
    #     self.lblTitle.place(relx=0.045, rely=0.075, height=21, width=414)
    #     self.lblTitle.configure(background="#d9d9d9")
    #     self.lblTitle.configure(disabledforeground="#a3a3a3")
    #     self.lblTitle.configure(foreground="#000000")
    #     self.lblTitle.configure(text='''Title''')
    #     self.lblTitle.configure(width=414)    
        
    def play_pause(self, pos = 0):
        self.clear_box()
        if self.paused:
            self.stream_paused = False
            mixer.music.unpause()
            self.pause_event.set() #allow playing
            self.statusbar['text'] = "Playing music" + ' - ' + self.title
            self.paused = False
            self.toggle_pause()
        else:
            self.stop()
            sleep(1)
            selected_song = self.playlistbox.curselection()
            if selected_song == ():#default case
                self.index = 0
                self.playlistbox.see(0)
                self.playlistbox.selection_set(0)
            else:
                #print(selected_song)
                self.index = int(selected_song[0])
            self.title = self.playlistbox.get(self.index).split('<-')[0].strip(' ')
            print(self.title)
            file_path = self.playlist[self.playlistbox.get(self.index)]
            print(file_path)
            #check to see if its an ip
            if file_path[0]=='&':
                self.toggle_pause()
                if file_path[1:] in self.network.addr_list:
                    addr = file_path[1:]
                    self.req_remote = True
                    #print('!!!remote!!!')
                    self.btn_skip_fore.configure(command = self.stream_go_to_next)
                    self.btn_skip_back.configure(command = self.stream_go_back)
                    self.btn_stop.configure(command = self.stream_stop)
                    self.request_from_name = addr#todo, update to name
                    self.stream_next = True
                    self.network.remote_play_request(addr, self.title)
                else: #address lost
                    True#todo, add a catch to remove the addr
            else:
                self.req_remote = False #becomes true if this player requests remote play
                self.toggle_pause()
                self.btn_skip_fore.configure(command = self.go_to_next)
                self.btn_skip_back.configure(command = self.go_back)
                self.btn_stop.configure(command = self.stop)

                try:
                    mixer.music.load(file_path)
                    self.show_details(file_path, pos)
                    mixer.music.play()
                except:
                    tkinter.messagebox.showerror('Error',
                        'Could not open the file, please check and try again.')
            self.statusbar['text'] = "Playing music" + ' - ' + self.title
    
    # def stream_play_pause(self):
    #     if self.stream_paused == True:
    #         self.stream_paused = False
    #         self.stream_btn_play_pause.configure(text=' ነ ', command=self.stream_play_pause)
            
    #     else:
    #         self.stream_paused = True
    #         self.stream_btn_play_pause.configure(text=' ᢰ ', command=self.stream_play_pause)
            

    def stream_go_to_next(self, reverse = False):
        #self.pause_event.set() #allow playing
        self.stream_stop()
        #if its a stream control window will launch again
        self.go_to_next()

    def go_to_next(self, reverse = False):
        if self.stream_next == True:
            size = self.playlistbox.size()
            size_index = size - 1
            if reverse:
                next_index = self.index - 1
                if next_index < 0:
                    next_index = size_index
            else:
                next_index = self.index + 1
                if next_index > size_index:
                    next_index = 0
            self.paused = False
            print(next_index)
            self.playlistbox.see(next_index)
            self.playlistbox.selection_clear(0,size)
            self.playlistbox.selection_set(next_index)
            self.play_pause()

    def stop(self):
        mixer.music.stop()
        self.paused = False
        self.btn_play_pause.configure(text=' ᢰ ', command=self.play_pause)
        self.statusbar['text'] = "Music Stopped"

    def user_stream_stop(self):
        self.stream_next = False #so next wont autoplay
        self.stream_stop()

    def stream_stop(self):
        print('stream stop called')
        self.remote_play_event.clear()#stops the player
        print('clear remote event')
        self.req_remote = False
        print("stream stopped")
        self.stop()

    def pause_music(self):
        self.paused = True
        self.toggle_pause()
        mixer.music.pause()
        self.pause_event.clear() #pause  
        self.statusbar['text'] = "Music Paused" + ' - ' + self.title
        
    def go_back(self):
        #if in first 7 secs, skip to last
        size = self.playlistbox.size()
        if self.current_time <= 7:
            self.go_to_next(reverse = True)
        else:
            self.playlistbox.see(self.index)
            self.playlistbox.selection_clear(0,size)
            self.playlistbox.selection_set(self.index)  
            self.play_pause()
            self.statusbar['text'] = "Playing music" + ' - ' + self.title
    
    def stream_go_back(self):
        self.stream_stop()
        #if its a stream control window will launch again
        self.go_to_next(reverse = True)
        
    def shuffle(self):
        shuff_list = []
        size = self.playlistbox.size()
        for iTitle in range(size):
            title = self.playlistbox.get(iTitle)
            if title is not '':
                shuff_list.append(title) 
        self.playlistbox.delete(0,size)
        random.shuffle(shuff_list)
        for title in shuff_list:
            index = self.playlistbox.size()
            self.playlistbox.insert(index, title)
            if title == self.title:
                self.index = index
        self.playlistbox.see(self.index)
        self.playlistbox.selection_clear(0,size)
        self.playlistbox.selection_set(self.index)   
        
        
    def set_vol(self,val):
        self.volume = float(val)
        mixer.music.set_volume(self.volume)
        # set_volume of mixer takes value only from 0 to 1. Example - 0, 0.1,0.55,0.54.0.99,1

    def mute_music(self):
        if self.muted:  # Unmute the music
            self.btn_mute.configure(text=' ᚡ ')
            self.scale_vol.set(self.volAtMute)
            self.muted = False
        else:  # mute the music
            self.volAtMute = mixer.music.get_volume()
            mixer.music.set_volume(0)
            self.btn_mute.configure(text=' ᚾ ')
            self.scale_vol.set(0)
            self.muted = True

    def on_closing(self, top):
        print(self.network.addr_list)
        self.shutdown.set()
        self.network.close_server()
        mixer.music.stop()
        #TODO: send close signal to all lower processes
        top.destroy()
        
    def about_us(self):
        tkinter.messagebox.showinfo('About DMP',
            'This is a music player build using Python Tkinter by Jon L. Battison')
            
    def toggle_back(self,value):
        if value == True: #we are going to beginning of song
            ToolTip(self.btn_skip_back, tooltip_font, '''Skip to Beginning''', delay=0.5)
        else: # we are going to last song
            ToolTip(self.btn_skip_back, tooltip_font, '''Skip to Last''', delay=0.5)
    
    def toggle_pause(self):
        if self.paused == True:
            self.btn_play_pause.configure(text=' ᢰ ', command=self.play_pause)
        else:
            self.btn_play_pause.configure(text=' ነ ', command=self.pause_music)
        
                
    @staticmethod
    def popup1(event, *args, **kwargs):
        Popupmenu1 = tk.Menu(root, tearoff=0)
        Popupmenu1.configure(activebackground="#f9f9f9")
        Popupmenu1.configure(activeborderwidth="1")
        Popupmenu1.configure(activeforeground="black")
        Popupmenu1.configure(background="#d9d9d9")
        Popupmenu1.configure(borderwidth="1")
        Popupmenu1.configure(disabledforeground="#a3a3a3")
        Popupmenu1.configure(font="-family {Segoe UI} -size 9")
        Popupmenu1.configure(foreground="black")
        Popupmenu1.post(event.x_root, event.y_root)

# ======================================================
# Modified by Rozen to remove Tkinter import statements and to receive
# the font as an argument.
# ======================================================
# Found the original code at:
# http://code.activestate.com/recipes/576688-tooltip-for-tkinter/
# ======================================================

from time import time, localtime, strftime

class ToolTip(tk.Toplevel):
    """
    Provides a ToolTip widget for Tkinter.
    To apply a ToolTip to any Tkinter widget, simply pass the widget to the
    ToolTip constructor
    """
    def __init__(self, wdgt, tooltip_font, msg=None, msgFunc=None,
                 delay=1, follow=True):
        """
        Initialize the ToolTip

        Arguments:
          wdgt: The widget this ToolTip is assigned to
          tooltip_font: Font to be used
          msg:  A static string message assigned to the ToolTip
          msgFunc: A function that retrieves a string to use as the ToolTip text
          delay:   The delay in seconds before the ToolTip appears(may be float)
          follow:  If True, the ToolTip follows motion, otherwise hides
        """
        self.wdgt = wdgt
        # The parent of the ToolTip is the parent of the ToolTips widget
        self.parent = self.wdgt.master
        # Initalise the Toplevel
        tk.Toplevel.__init__(self, self.parent, bg='black', padx=1, pady=1)
        # Hide initially
        self.withdraw()
        # The ToolTip Toplevel should have no frame or title bar
        self.overrideredirect(True)

        # The msgVar will contain the text displayed by the ToolTip
        self.msgVar = tk.StringVar()
        if msg is None:
            self.msgVar.set('No message provided')
        else:
            self.msgVar.set(msg)
        self.msgFunc = msgFunc
        self.delay = delay
        self.follow = follow
        self.visible = 0
        self.lastMotion = 0
        # The text of the ToolTip is displayed in a Message widget
        tk.Message(self, textvariable=self.msgVar, bg='#FFFFDD',
                font=tooltip_font,
                aspect=1000).grid()

        # Add bindings to the widget.  This will NOT override
        # bindings that the widget already has
        self.wdgt.bind('<Enter>', self.spawn, '+')
        self.wdgt.bind('<Leave>', self.hide, '+')
        self.wdgt.bind('<Motion>', self.move, '+')

    def spawn(self, event=None):
        """
        Spawn the ToolTip.  This simply makes the ToolTip eligible for display.
        Usually this is caused by entering the widget

        Arguments:
          event: The event that called this funciton
        """
        self.visible = 1
        # The after function takes a time argument in miliseconds
        self.after(int(self.delay * 1000), self.show)

    def show(self):
        """
        Displays the ToolTip if the time delay has been long enough
        """
        if self.visible == 1 and time() - self.lastMotion > self.delay:
            self.visible = 2
        if self.visible == 2:
            self.deiconify()

    def move(self, event):
        """
        Processes motion within the widget.
        Arguments:
          event: The event that called this function
        """
        self.lastMotion = time()
        # If the follow flag is not set, motion within the
        # widget will make the ToolTip disappear
        #
        if self.follow is False:
            self.withdraw()
            self.visible = 1

        # Offset the ToolTip 10x10 pixes southwest of the pointer
        self.geometry('+%i+%i' % (event.x_root+20, event.y_root-10))
        try:
            # Try to call the message function.  Will not change
            # the message if the message function is None or
            # the message function fails
            self.msgVar.set(self.msgFunc())
        except:
            pass
        self.after(int(self.delay * 1000), self.show)

    def hide(self, event=None):
        """
        Hides the ToolTip.  Usually this is caused by leaving the widget
        Arguments:
          event: The event that called this function
        """
        self.visible = 0
        self.withdraw()

# ===========================================================
#                   End of Class ToolTip
# ===========================================================

if __name__ == '__main__':
    vp_start_gui()





